import { BrowserWindow, app, safeStorage } from "electron";

import { HeliumWindowOptions, HeliumWindowState } from "../types";
import ShopifyCli from "./ShopifyCli";
import {
  ConnectStoreOptions,
  InitalState,
  OpenThemeResult,
  PreviewState,
  StoreInfo,
  ThemeDirectoryChange,
  ThemeFileSystemEntry,
  ThemeInfo,
} from "common/types";
import isDev from "electron-is-dev";
import { generateHeliumId } from "../generateHeliumId";
import path from "path";
import main from "main/services/ipc/main";
import fileSystemService from "main/services/fs";
import themeService from "main/services/theme";
import { FSWatcher, watch } from "chokidar";
import { isJunk } from "junk";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const DEFAULT_INITAL_STATE: InitalState = {
  connectedStore: null,
  currentTheme: null,
  previewState: PreviewState.OFF,
  themeFiles: [],
};

export class HeliumWindow {
  public browserWindow: BrowserWindow;
  private currentTheme: ThemeInfo | null = null;
  private connectedStore: StoreInfo | null = null;
  public shopifyCli: ShopifyCli;
  private directoryWatchers: Map<string, FSWatcher>;
  constructor(private options?: HeliumWindowOptions) {
    this.directoryWatchers = new Map<string, FSWatcher>();
    console.log(options);
    this.shopifyCli = new ShopifyCli(this);
    // console.log(path.resolve(__dirname, "../assets/icons/Desktop Logo.icns"));
    // console.log(path.join(__dirname, "../assets", "icons", "helium.png"));

    this.browserWindow = new BrowserWindow({
      title: "Helium IDE",
      center: true,
      // frame: false,
      width: 1200,
      height: 900,
      minHeight: 600,
      minWidth: 600,
      backgroundColor: "#171717",
      // icon: path.resolve(__dirname, "../assets", "icons", "helium.png"),
      show: false,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
    });

    // wait for the dom to be ready before showing the window
    // think about this
    this.browserWindow.webContents.once('dom-ready', () => {
      this.browserWindow.show();
    })

    this.browserWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    if (isDev) {
      this.browserWindow.webContents.openDevTools();
    }
  }

  public getId() {
    return this.browserWindow.id;
  }

  public getCurrentTheme() {
    return this.currentTheme;
  }

  public getConnectedStore() {
    return this.connectedStore;
  }

  public async openTheme(themePath: string): Promise<OpenThemeResult> {
    // RITGHT NOW, THIS ONLY WORKS THEMES THAT USE THE STANDARD OS 2.0 DIRECTORY STRUCTURE

    // needs to be an absolute path
    // should be absolute path (base it off on the root path)
    const resolvedThemePath = path.isAbsolute(themePath) ? themePath : path.resolve(themePath);

    // check if path exists. if not, throw error
    if (!(await fileSystemService.pathExists(resolvedThemePath))) {
      throw new Error(`${resolvedThemePath} does not exist`);
    }
    // read the directory to get all the root level files and folders in array
    const files = await fileSystemService.readDirectory(resolvedThemePath);
    // validate theme file structure. if not valid, throw error
    // think about this... what if they user is using a setup that includes some kind of build step??
    // also this does not take into account .git folders and the rest
    if (!(await this.isThemeFileStructureValid(resolvedThemePath, files))) {
      throw new Error(`${resolvedThemePath} is not a valid OS 2.0 theme directory`); // need a better mesage
    }
    // read theme info from settings_schema.json
    const settingsSchemaFilePath = themeService.configPath(
      resolvedThemePath,
      "settings_schema.json"
    );
    if (!(await fileSystemService.pathExists(settingsSchemaFilePath))) {
      throw new Error(`${settingsSchemaFilePath} does not exist`);
    }

    const { theme_author, theme_name, theme_version } =
      await themeService.readThemeInfo(settingsSchemaFilePath);

    const openedTheme: ThemeInfo = {
      path: resolvedThemePath,
      name: theme_name,
      author: theme_author,
      version: theme_version,
      shopifyId: null,
    };

    // attach watcher to this path so the ui is notified of any changes at the root level
    // this.attatchDirectoryWatcher(themePath);

    app.addRecentDocument(resolvedThemePath);

    this.currentTheme = openedTheme;

    return { themeInfo: openedTheme, files }; 
  }

  public attatchDirectoryWatcher(dirPath: string) {
    if (this.directoryWatchers.has(dirPath)) {
      throw new Error(`${dirPath} already has watcher attached`);
    }
    const watcher = watch(dirPath, {
      // LOOK INTO ALL OPTIONS
      // think/confirm about this
      ignored: (testPath) => isJunk(testPath), // should just be file name
      followSymlinks: false,
      // depth: 1// confirm this
    });

    const onDirectoryChange = () => {
      const change: ThemeDirectoryChange = {
        changedPath: dirPath,
      };
      main.emitEventFromWindow(this, "on-directory-change", change);
    }

    watcher.on("addDir", onDirectoryChange);
    watcher.on("unlinkDir", onDirectoryChange);

    this.directoryWatchers.set(dirPath, watcher);
  }

  public removeDirectoryWatcher(dirPath: string) {
    if (!this.directoryWatchers.has(dirPath))
      throw new Error(`There is no directory path ${dirPath} being watched`);

    const watcher = this.directoryWatchers.get(dirPath) as FSWatcher;

    // need to confirm which method to use
    watcher.close();
    // watcher.unwatch(dirPath);

    this.directoryWatchers.delete(dirPath);
  }

  private async isThemeFileStructureValid(
    themePath: string,
    files: ThemeFileSystemEntry[]
  ) {
    // IN ITS CURRENT FORM, THIS METHOD DOES NOT WORK

    // the only way for this method to work is to check if the theme folder at least has the vaid theme paths in its directory

    // much easier to use array as it in an array form, it will only have the files and folders it has, so it is
    // easier to validate if there are any subdirectories that aren't meant to be there

    // https://shopify.dev/docs/themes/architecture#directory-structure-and-component-types
    // should return the reason

    // should at least have a layout/theme.liquid. if this is not present, throw return false
    if (!fileSystemService.pathExists(themeService.layoutPath(themePath, "theme.liquid"))) return false;

    // get all directories
    // const directories = files.filter(file => file.isDirectory);
    const directoryPaths = files.filter(file => file.isDirectory).map(dir => dir.path);

    // theme paths that are meant to be in the folder
    const themePaths = [
      themeService.accessPath(themePath),
      themeService.configPath(themePath),
      themeService.localesPath(themePath),
      themeService.sectionsPath(themePath),
      // ThemeService.snippetsPath(themePath),
      themeService.templatesPath(themePath), 
    ];

    return themePaths.every((themeDir) => directoryPaths.includes(themeDir));
  }

  public connectStore(options: ConnectStoreOptions) {
    //in UI make sure preview is not running
    // this is used for new stores
    // will this method be async???
    const themeAccessPassword = safeStorage.encryptString(options.password).toString();

    const store = {
      heliumId: generateHeliumId(),
      themeAccessPassword,
      url: options.storeUrl,
    };

    this.connectedStore = store;
    this.emitEvent('on-store-change', this.connectedStore);
  }

  public getWindowState(): HeliumWindowState {
    return {
      isMinimized: this.browserWindow.isMinimized(),
      isMaximized: this.browserWindow.isMaximized(),
      isFocused: this.browserWindow.isFocused(),
    };
  }

  public async loadInitalState(): Promise<InitalState> {
    // if there are any inital options (stores or themes) to be loaded
    if (this.options) {
      const { themePathOrUrl, connectedStore, previewOn } = this.options;
      let files: ThemeFileSystemEntry[] = [];

      if (themePathOrUrl) {
        const result = await this.openTheme(themePathOrUrl);
        files = result.files;
      }

      if (connectedStore) {
        this.connectStore(connectedStore);
      }

      if (previewOn) {
        await this.shopifyCli.startThemePreview();
        // handle if there was error
      }

      return {
        currentTheme: this.currentTheme,
        themeFiles: files,
        connectedStore: this.connectedStore,
        previewState: this.shopifyCli.getPreviewState(),
      };
    } else {
      return DEFAULT_INITAL_STATE;
    }
    // the loading screen should show for a minimum of 1 or 2 seconcds (500ms???) so it doesnt seem too jarring
    // if loading takes longer that is fine
  }

  public emitEvent<T = void>(eventName: string, args?: T) {
    this.browserWindow.webContents.send(eventName, args);
    // main.emitEventFromWindow(this, "on-inital-state-ready", initalState);
  }

  public close() {
    // needs to shutdown everything (including preview if on)
    this.browserWindow.close();
  }
}
