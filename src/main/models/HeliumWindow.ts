import { BrowserWindow, safeStorage } from "electron";

import { HeliumWindowOptions, HeliumWindowState } from "../types";
import ShopifyCli from "./ShopifyCli";
import { ConnectStoreOptions, InitalState, PreviewState, StoreInfo, ThemeInfo } from "common/types";
import { initAppService } from "../services/app";
import { initFsService } from "../services/fs";
import { initShopifyService } from "../services/shopify";
import { generateHeliumId } from "main/generateHeliumId";
import isDev from "electron-is-dev";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export class HeliumWindow {
  public browserWindow: BrowserWindow;
  private currentTheme: ThemeInfo | null = null; // for now (might need theme)
  private connectedStore: StoreInfo | null = null; // for now
  public shopifyCli: ShopifyCli;
  constructor(options?: HeliumWindowOptions) {
    console.log(options);
    // should not be able to open duplicate windows (windows with the same theme)

    // should this be a circular dependency???
    this.shopifyCli = new ShopifyCli(this);
    // console.log(path.resolve(__dirname, "../assets/icons/Desktop Logo.icns"));
    // console.log(path.join(__dirname, "../assets", "icons", "helium.png"));

    this.browserWindow = new BrowserWindow({
      title: "Helium IDE",
      center: true,
      // frame: false,
      width: 1200,
      height: 900,
      minHeight: 600,
      minWidth: 600,
      // icon: path.resolve(__dirname, "../assets", "icons", "helium.png"),
      show: false,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
    });

    // these functions need to be called after the BrowserWindow has been created
    // since the browserWindow.id is used when these functions are called
    initAppService(this);
    initShopifyService(this);
    initFsService(this);

    if (isDev) {
      this.browserWindow.webContents.openDevTools();
    }

    // // think about this
    // might just end up showing the window immediately and setting the background color
    this.browserWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // makes the app feel slow
    this.browserWindow.webContents.on("dom-ready", () => {
      this.browserWindow.show();
    });

  }

  //   public setTheme(path: string) {}
  //   public disconnectCurrentStore() {}
  //   public connectStore() {}

  public getId() {
    return this.browserWindow.id;
  }

  public getCurrentTheme() {
    return this.currentTheme;
  }

  public getConnectedStore() {
    return this.connectedStore;
  }

  public connectStore(options: ConnectStoreOptions) {
    //in UI make sure preview is not running
    // this is used for new stores
    // will this method be async???
    const store = {
      heliumId: generateHeliumId(),
      themeAccessPassword: safeStorage.encryptString(options.password).toString(),
      url: options.storeUrl
    }

    this.connectedStore = store;

    
    return Promise.resolve();
  }

  public getWindowState(): HeliumWindowState {
    return {
      isMinimized: this.browserWindow.isMinimized(),
      isMaximized: this.browserWindow.isMaximized(),
      isFocused: this.browserWindow.isFocused(),
    };
  }

  public getInitalState(): InitalState {
    return {
      connectedStore: this.connectedStore,
      currentTheme: this.currentTheme, // also send ThemeFileEntry array (might be a tuple)
      previewState: PreviewState.OFF, // define this in the UI?? (there could be a case where the user wants the window/app launched with the preview open)
    }
  }

  public triggerEvent<T>(eventName: string, args: T) {
    this.browserWindow.webContents.send(eventName, args);
  }
}
