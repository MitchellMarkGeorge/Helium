import { BrowserWindow, safeStorage } from "electron";

import { HeliumWindowOptions, HeliumWindowState } from "../types";
import ShopifyCli from "./ShopifyCli";
import {
  ConnectStoreOptions,
  InitalState,
  OpenThemeResult,
  PreviewState,
  StoreInfo,
  ThemeDirectoryChange,
  ThemeDirectoryChangeType,
  ThemeFileSystemEntry,
  ThemeInfo,
} from "common/types";
import isDev from "electron-is-dev";
import { generateHeliumId } from "../generateHeliumId";
import path from "path";
import main from "main/services/ipc/main";
import { isHidden, pathExists, readDirectory } from "main/services/fs";
import theme from "main/services/theme";
import { FSWatcher, watch } from "chokidar";
import { isJunk } from "junk";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const DEFAULT_INITAL_STATE: InitalState = {
  connectedStore: null,
  currentTheme: null,
  previewState: PreviewState.OFF,
  themeFiles: [],
};

export class HeliumWindow {
  public browserWindow: BrowserWindow;
  private currentTheme: ThemeInfo | null = null;
  private connectedStore: StoreInfo | null = null;
  public shopifyCli: ShopifyCli;
  private directoryWatchers: Map<string, FSWatcher>;
  constructor(private options?: HeliumWindowOptions) {
    this.directoryWatchers = new Map<string, FSWatcher>();
    console.log(options);
    // should this be a circular dependency???
    this.shopifyCli = new ShopifyCli(this);
    // console.log(path.resolve(__dirname, "../assets/icons/Desktop Logo.icns"));
    // console.log(path.join(__dirname, "../assets", "icons", "helium.png"));

    this.browserWindow = new BrowserWindow({
      title: "Helium IDE",
      center: true,
      // frame: false,
      width: 1200,
      height: 900,
      minHeight: 600,
      minWidth: 600,
      backgroundColor: "#171717",
      // icon: path.resolve(__dirname, "../assets", "icons", "helium.png"),
      // show: false,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
    });

    this.browserWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    if (isDev) {
      this.browserWindow.webContents.openDevTools();
    }
  }

  //   public setTheme(path: string) {}
  //   public disconnectCurrentStore() {}
  //   public connectStore() {}

  public getId() {
    return this.browserWindow.id;
  }

  public getCurrentTheme() {
    return this.currentTheme;
  }

  public getConnectedStore() {
    return this.connectedStore;
  }

  public async openTheme(themePath: string): Promise<OpenThemeResult> {
    // needs to be an absolute path
    if (!path.isAbsolute(themePath)) {
      themePath = path.resolve(themePath);
    }

    // check if path exists. if not, throw error
    if (!(await pathExists(themePath))) {
      throw new Error(`${themePath} does not exist`);
    }
    // read the directory to get all the root level files and folders in array
    const files = await readDirectory(themePath);
    // validate theme file structure. if not valid, throw error
    if (!(await this.isThemeFileStructureValid(themePath, files))) {
      throw new Error(`${themePath} is not a valid theme`);
    }
    // read theme info from settings_schema.json
    const settingsSchemaFilePath = theme.configPath(
      themePath,
      "settings_schema.json"
    );
    if (!(await pathExists(settingsSchemaFilePath))) {
      throw new Error(`${settingsSchemaFilePath} does not exist`);
    }

    const { theme_author, theme_name, theme_version } =
      await theme.readThemeInfo(settingsSchemaFilePath);

    const openedTheme: ThemeInfo = {
      path: themePath,
      name: theme_name,
      author: theme_author,
      verson: theme_version,
      shopifyId: null,
    };

    // attach watcher to this path so the ui is notified of any changes at the root level
    this.attatchDirectoryWatcher(themePath);

    this.currentTheme = openedTheme;

    // return { themeInfo: this.currentTheme, files: [] }; // for now
    return { themeInfo: openedTheme, files }; // for now
  }

  public attatchDirectoryWatcher(dirPath: string) {
    if (this.directoryWatchers.has(dirPath))
      throw new Error(`${dirPath} already has watcher attached`);
    const watcher = watch(dirPath, {
      // LOOK INOT ALL OPTIONS
      // think/confirm about this
      ignored: (testPath) => {
        const resolvedPath = path.resolve(testPath);
        return isJunk(resolvedPath) || isHidden(resolvedPath);
      },
      followSymlinks: false,
      // depth: 1// confirm this
    });

    watcher.on("addDir", (path) => {
      const change: ThemeDirectoryChange = {
        // should this be dirPath instead???
        // need to test this
        changedPath: path,
        type: ThemeDirectoryChangeType.FOLDER_ADDED,
      };
      main.emitEventFromWindow(this, "on-directory-change", change);
    });

    watcher.on("unlinkDir", (path) => {
      const change: ThemeDirectoryChange = {
        changedPath: path,
        type: ThemeDirectoryChangeType.FOLDER_ADDED,
      };
      main.emitEventFromWindow(this, "on-directory-change", change);
    });

    this.directoryWatchers.set(dirPath, watcher);
  }

  public removeDirectoryWatcher(dirPath: string) {
    if (!this.directoryWatchers.has(dirPath))
      throw new Error(`There is no directory path ${dirPath}`);

    const watcher = this.directoryWatchers.get(dirPath);

    // need to confirm which method to use
    watcher.close();
    watcher.unwatch(dirPath);

    this.directoryWatchers.delete(dirPath);
  }

  private async isThemeFileStructureValid(
    themePath: string,
    files: ThemeFileSystemEntry[]
  ) {
    // much easier to use array as it in an array form, it will only have the files and folders it has, so it is
    // easier to validate if there are any subdirectories that aren't meant to be there

    // https://shopify.dev/docs/themes/architecture#directory-structure-and-component-types
    // should return the reason

    // should at least have a layout/theme.liquid. if this is not present, throw return false
    if (!pathExists(theme.layoutPath(themePath, "theme.liquid"))) return false;

    const VALID_THEME_PATHS = [
      theme.accessPath(themePath),
      theme.configPath(themePath),
      theme.localesPath(themePath),
      theme.sectionsPath(themePath),
      theme.snippetsPath(themePath),
      theme.templatesPath(themePath), // should this be theme/customers instead
    ];

    for (let i = 0; i < files.length; i++) {
      // loop over the `files` array and validate that the remaining subdirectories are of the allowed directory types
      const { path: fileEntryPath, isDirectory } = files[i];
      if (isDirectory) {
        // if there is only one item in the array and it is the above case, continue
        if (!VALID_THEME_PATHS.includes(fileEntryPath)) return false;
        // if one of the directory paths is not one of the valid theme paths, it is not valid
      }
    }

    // if none of directory paths are invalid, return true
    return true;
  }

  public connectStore(options: ConnectStoreOptions) {
    //in UI make sure preview is not running
    // this is used for new stores
    // will this method be async???
    const store = {
      heliumId: generateHeliumId(),
      themeAccessPassword: safeStorage
        .encryptString(options.password)
        .toString(),
      url: options.storeUrl,
    };

    this.connectedStore = store;

    return Promise.resolve();
  }

  public getWindowState(): HeliumWindowState {
    return {
      isMinimized: this.browserWindow.isMinimized(),
      isMaximized: this.browserWindow.isMaximized(),
      isFocused: this.browserWindow.isFocused(),
    };
  }

  public async loadInitalState(): Promise<InitalState> {
    // if there are any inital options (stores or themes) to be loaded, they will be done here
    if (this.options) {
      const { themePathOrUrl, connectedStore, previewOn } = this.options;
      let files: ThemeFileSystemEntry[] = [];

      if (themePathOrUrl) {
        const result = await this.openTheme(themePathOrUrl);
        files = result.files;
      }

      if (connectedStore) {
        this.connectStore(connectedStore);
      }

      if (previewOn) {
        await this.shopifyCli.startThemePreview();
      }

      return {
        currentTheme: this.currentTheme,
        themeFiles: files,
        connectedStore: this.connectedStore,
        previewState: this.shopifyCli.getPreviewState(),
      };
    } else {
      return DEFAULT_INITAL_STATE;
    }

    // if (this.options?.themePathOrUrl)

    // the loading screen should show for a minimum of 1 or 2 seconcds (500ms???) so it doesnt seem too jarring
    // if loading takes longer that is fine
  }

  public emitOnInitalStateReady(initalState: InitalState) {
    main.emitEventFromWindow(this, "on-inital-state-ready", initalState);
  }
}
